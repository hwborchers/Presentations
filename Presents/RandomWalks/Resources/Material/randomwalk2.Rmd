---
title: "R Notebook"
output: html_notebook
---

```{r}
require(dqrng)
```

## Random Number Generators

We will compare three different *random number generators* (RNGs), the one in Base R, the default uniform random number generator in package **dqrng**, and a straightforward implementation of Knuth's TAOCP-2002 generator.

The Knuth-TAOCP-2002 generator requires 100 uniformly distributed random numbers as initial values. Utilizing random numbers generated by another random number generator is considered problematic, therefore we will make use of 'true' random numbers generated from a physical process. Package **qrandom** returns such numbers, derived from quantum statistical fluctuations and loaded from an Internet server.

```{r}
require(qrandom, quietly = TRUE)
qseed <- qrandomunif(n = 100, a = 0, b = 1)
head(qseed)
```

The implementation of Knuth-TAOCP-2002, called `myTAO`, looks like this:

```{r}
myTAO <- function(seed) {
    local({
        R <- vector(mode = "numeric", length = 2000)
        R[1:100] <- seed
        for (k in 101:2000)
            R[k] <- (R[k-37] + R[k-100]) %% 1
        k <- 2000; i <- 2000 - 37; j <- 2000 - 100
        frand <- function() {
            k <<- (k %% 2000) + 1
            i <<- (i %% 2000) + 1
            j <<- (j %% 2000) + 1
            z <- (R[i] + R[j]) %% 1
            R[k] <<- z
            return(z)
        }
        return(frand)
    })
}
```

The first 2000 generated random numbers are thrown away. After that, uniform random numbers in the interval `[0, 1]` are generated one by one, that is there is no vectorization involved. Still, the calculation is relatively fast, as we will see.

## Symmetric Random Walk

> A random walk is a mathematical object, known as a stochastic or random process, that describes a path that consists of a succession of random steps on some mathematical space such as the integers. It starts at 0 and at each step moves +1 or âˆ’1 with equal probability.
--- Wikipedia

The following funktion `randomWalk()` generates a random walk of length `N`. It employs a random number generator `myrandom()` that has to be defined by the user.

```{r}
randomWalk <- function(N = 1024) {
    result <- rep(NA, N)
    a <- 0
    for (i in 1:N) {
        a <- a + ( if (runif(1) >= 0.5) 1 else -1 )
        result[i] <- a
    }
    result
}
```

We can plot the random walk as a two-dimensional graph, say of step length 1024.

```{r}
k <- 1024
rw <- randomWalk(N = k)
plot(0:k, c(0, rw), type = 'l', col = "darkred",
     main = "Random Walk", xlab = "No. of Steps", ylab ="Elongation")
abline(h = 0, col = "darkgrey"); grid()
```

We are considering *symmetric* random walks, that is the probability to make a move to the right (+1) or to the left (-1) is equal to 0.5 exactly. Theory says that in this case that a symmetric random walk will return to its initial position almost always, that is with probability 1.

**QUESTION**: Which number of steps guaranties that a symmetric random walk will return to 0 with probability 0.975 (or 0.99, etc.). This means only 2.5 percent of random walks will show a "run-away" effect.

## A Stochastic Simulation

We will compute thousands of random walk and take down their length until returning to 0. As some of such random walks may be extremely long, hundreds of millions or even billions of steps, we will stop after `M = 10000` steps to make the computation possible.

Here is a function that will do this for us. With `N` random walks it will return a vector of `N` entries, each the number of steps until it returned to zero.

```{r}
rwalk <- function(N, M = 10000) {
    result <- rep(0, N)
    for (i in 1:N) {
        steps <- 1
        a <- if (dqrunif(1) >= 0.5) 1 else -1
        a <- a + if (dqrunif(1) >= 0.5) 1 else -1
        while (a != 0) {
            steps <- steps + 1
            a <- a + if (dqrunif(1) >= 0.5) 1 else -1
            a <- a + if (dqrunif(1) >= 0.5) 1 else -1
            if (steps >= M) break
        }
        result[i] <- steps
    }
    result
}
```

After fixing the random number generator, we generate `N = 100000` random walk and take notes of their number of steps.

```{r}
N <- 100000; M = 10000
no_steps <- 2 * rwalk(N, M)           # runif: 20 s; dqrunif: 7 s
hist(log2(no_steps), col = "gray")
```

## Estimating Number of Steps

To tabulate the number of steps, we will apply "run length encoding" as is provided by the R function `rle()`, but first sort the vector containing the number of steps.

```{r}
r <- rle(sort(no_steps))
x <- r$values
y <- cumsum(r$lengths/sum(r$lengths))
```

Now we can plot the cumulative distribution function.

```{r}
plot(x, y, type = 'l', col = "darkblue")
abline(h = 0.975, lty = 2, col = "darkgray"); grid()
```

We want to identify where the blue line crosses the probability `P = 0.975`. The easiest way is to find the index of the first occurrence `y >= 0.975`.

```{r}
ind <- which(y > 0.975)[1]
cbind(x[(ind-2):(ind+2)], y[(ind-2):(ind+2)])
```

It looks like the minimum number of steps is somewhere between 1000 and 1100. To make this estimate more precise, we will repeat this procedure a hundred times.

```{r}
N <- 100000; M = 10000
result <- numeric(100)
for (i in 1:100) {
    no_steps <- 2 * rwalk(N, M)
    r <- rle(sort(no_steps))
    x <- r$values
    y <- cumsum(r$lengths/sum(r$lengths))
    ind <- which(y > 0.975)[1]
    result[i] <- ind
}
```







## Method 1

```{r}
dqset.seed(as.numeric(Sys.time()))
N <- 100000000
s <- ifelse(dqrunif(N) < 0.5, -1, 1)
sc <- cumsum(s)
s0 <- c(0, which(sc == 0))
no_steps <- diff(s0)
r <- rle(sort(no_steps))
x <- r$values
y <- cumsum(r$lengths/sum(r$lengths))
ind <- which(y > 0.975)[1]
cbind(x[(ind-2):(ind+2)], y[(ind-2):(ind+2)])
plot(x[1:ind], y[1:ind], type = 'l', col = "blue", ylim = c(0.5, 1.0))
abline(h = 0.975, lty = 2, col = "darkgray"); grid()
```

## Method 2

```{r}
rwalk2 <- function(N) {
    result <- rep(0, N)
    for (i in 1:N) {
        steps <- 1
        a <- if (dqrunif(1) >= 0.5) 1 else -1
        a <- a + if (dqrunif(1) >= 0.5) 1 else -1
        while (a != 0) {
            steps <- steps + 1
            a <- a + if (dqrunif(1) >= 0.5) 1 else -1
            a <- a + if (dqrunif(1) >= 0.5) 1 else -1
            if (steps >= 2048) break
        }
        result[i] <- steps
    }
    result
}
```

```{r}
N <- 100000
no_steps <- 2 * rwalk2(N)           # runif: 20 s; dqrunif: 7 s
hist(log2(no_steps), col = "gray")
```

```{r}
r <- rle(sort(no_steps))
x <- r$values
y <- cumsum(r$lengths/sum(r$lengths))
ind <- which(y > 0.975)[1]
cbind(x[(ind-2):(ind+2)], y[(ind-2):(ind+2)])

```

## Methode 3

```{r}
# require(dqrng)
myRand <- function() {
    local({
        R <- vector(mode = "numeric", length = 2000)
        R[1:100] <- dqrunif(100)
        for (k in 101:2000)
            R[k] <- (R[k-37] + R[k-100]) %% 1
        k <- 2000; i <- 2000 - 37; j <- 2000 - 100
        frand <- function() {
            k <<- (k %% 2000) + 1
            i <<- (i %% 2000) + 1
            j <<- (j %% 2000) + 1
            z <- (R[i] + R[j]) %% 1
            R[k] <<- z
            return(z)
        }
        return(frand)
    })
}
```

```{r}
myrand <- myRand()
rwalk3 <- function(N) {
    result <- rep(0, N)
    for (i in 1:N) {
        steps <- 1
        a <- if (myrand() >= 0.5) 1 else -1
        a <- a + if (myrand() >= 0.5) 1 else -1
        while (a != 0) {
            steps <- steps + 1
            a <- a + if (myrand() >= 0.5) 1 else -1
            a <- a + if (myrand() >= 0.5) 1 else -1
            if (steps >= 2048) break
        }
        result[i] <- steps
    }
    result
}
```

```{r}
N <- 100000
no_steps <- 2 * rwalk3(N)            # 14 sec
hist(log2(no_steps), breaks=12, col = "gray")
```

```{r}
r <- rle(sort(no_steps))
x <- r$values
y <- cumsum(r$lengths/sum(r$lengths))
ind <- which(y > 0.975)[1]
cbind(x[(ind-2):(ind+2)], y[(ind-2):(ind+2)])
```

